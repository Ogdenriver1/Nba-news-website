<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena Elite 2026 - Ultimate Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Rubik:wght@400;700;900&display=swap');

        :root {
            --primary: #FFD700;
            --accent: #FF4757;
            --dark: #2F3542;
            --blue: #1E90FF;
            --panel: rgba(30, 35, 45, 0.95);
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a1a;
            font-family: 'Rubik', sans-serif;
            user-select: none;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        /* UI LAYER */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* HUD */
        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
        }

        .currency-badge {
            background: var(--dark);
            color: var(--primary);
            padding: 10px 25px;
            border-radius: 50px;
            font-family: 'Black Han Sans', sans-serif;
            font-size: 32px;
            text-transform: uppercase;
            border: 4px solid #000;
            box-shadow: 0 6px 0 #000;
            transform: skew(-10deg);
        }

        .health-container {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%) skew(-10deg);
            width: 400px;
            height: 24px;
            background: #000;
            border: 4px solid #fff;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }

        .health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ee5253);
            transition: width 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* SCREENS */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(20px);
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s;
        }

        .screen.active {
            opacity: 1;
            pointer-events: auto;
        }

        .title {
            font-family: 'Black Han Sans', sans-serif;
            font-size: 100px;
            color: #fff;
            text-shadow: 0 10px 0 #000;
            transform: skew(-5deg) rotate(-2deg);
            background: linear-gradient(to bottom, #fff, #ddd);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            filter: drop-shadow(0 10px 0 rgba(0, 0, 0, 0.5));
        }

        .subtitle {
            color: var(--primary);
            letter-spacing: 2px;
            font-weight: 900;
            margin-bottom: 40px;
            font-size: 24px;
        }

        .card-grid {
            display: flex;
            gap: 20px;
            perspective: 1000px;
            margin-bottom: 40px;
        }

        .card {
            background: linear-gradient(135deg, #353b48, #2f3542);
            width: 220px;
            padding: 25px;
            border-radius: 20px;
            border: 4px solid #000;
            box-shadow: 0 8px 0 #000;
            transition: transform 0.1s;
            cursor: pointer;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-10px);
            background: linear-gradient(135deg, #3d4556, #363d4d);
        }

        .card:active {
            transform: translateY(0);
            box-shadow: 0 4px 0 #000;
        }

        .card h3 {
            margin: 15px 0 5px;
            color: #fff;
            font-family: 'Black Han Sans', sans-serif;
            font-size: 24px;
        }

        .card p {
            color: #a4b0be;
            font-size: 14px;
            margin: 0;
            font-weight: bold;
        }

        .btn-primary {
            background: var(--primary);
            color: #000;
            padding: 20px 60px;
            font-family: 'Black Han Sans', sans-serif;
            font-size: 28px;
            border: none;
            border-radius: 12px;
            border: 4px solid #000;
            box-shadow: 0 8px 0 #000;
            cursor: pointer;
            transition: transform 0.1s;
            text-transform: uppercase;
            transform: skew(-5deg);
        }

        .btn-primary:active {
            transform: skew(-5deg) translateY(4px);
            box-shadow: 0 4px 0 #000;
        }

        .btn-secondary {
            background: #fff;
            color: #000;
            padding: 15px 40px;
            font-family: 'Black Han Sans', sans-serif;
            font-size: 20px;
            border-radius: 12px;
            border: 4px solid #000;
            box-shadow: 0 6px 0 #000;
            cursor: pointer;
            margin-top: 15px;
        }

        /* DAMAGE OVERLAY */
        .vignette {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(0, 0, 0, 0.8));
            pointer-events: none;
        }

        .damage-flash {
            position: absolute;
            width: 100%;
            height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
    </style>
</head>

<body>
    <div id="debugHUD"
        style="position:fixed; top:5px; left:5px; background:rgba(0,0,0,0.5); color:lime; font-family:monospace; padding:5px; z-index:10000; pointer-events:none;">
        Debug Init...</div>
    <div class="damage-flash" id="dmgFlash"></div>

    <!-- HUD -->
    <div id="ui-layer">
        <div class="hud-top">
            <div class="currency-badge">üëë <span id="crownText">5
                </span></div>
            <div style="color:rgba(255,255,255,0.5); font-weight:900;">WASD + MOUSE</div>
        </div>
        <div class="health-container">
            <div class="health-bar" id="hpBar"></div>
        </div>
        <div class="vignette"></div>
        <div class="damage-flash" id="dmgFlash"></div>
    </div>

    <!-- MAIN MENU -->
    <div id="menu" class="screen active">
        <div class="title">BATTLE ARENA</div>
        <div class="subtitle">ELITE SQUAD 2026</div>

        <div class="currency-badge"
            style="display:inline-block; margin-bottom: 30px; transform: skew(-10deg) scale(0.8);">
            üëë <span id="menuCrowns">0</span>
        </div>

        <!-- Big Play Button for simplicity, or keep grid? keeping grid but styled -->

        <div style="display:flex; justify-content:center; gap:20px; margin-bottom:30px;">
            <div class="card mode-btn" onclick="setMode('SURVIVAL')"
                style="border-color:#FFD700; transform:scale(1.1); padding:15px; width:150px;">
                <div style="font-size:30px;">üíÄ</div>
                <h3>SURVIVAL</h3>
                <p style="font-size:12px;">Standard Wave</p>
            </div>
            <div class="card mode-btn" onclick="setMode('DEFENSE')" style="padding:15px; width:150px;">
                <div style="font-size:30px;">üõ°Ô∏è</div>
                <h3>DEFENSE</h3>
                <p style="font-size:12px;">Protect Core</p>
            </div>
            <div class="card mode-btn" onclick="setMode('BOSS')" style="padding:15px; width:150px;">
                <div style="font-size:30px;">üëπ</div>
                <h3>BOSS RUSH</h3>
                <p style="font-size:12px;">Titan Fight</p>
            </div>
        </div>

        <div class="title" style="font-size:20px; margin-bottom:20px; color:rgba(255,255,255,0.7);">SELECT ARENA</div>

        <div class="card-grid">
            <div class="card" onclick="initGame('Void')">
                <div style="font-size:40px;">üí®</div>
                <h3>Fart Lab</h3>
                <p>Win: 45 | Risk: 10</p>
            </div>
            <div class="card" onclick="initGame('Mars')">
                <div style="font-size:40px;">üåà</div>
                <h3>Neon Time</h3>
                <p>Win: 150 | Risk: 40</p>
            </div>
            <div class="card" onclick="initGame('Cyber')">
                <div style="font-size:40px;">‚ù§Ô∏è</div>
                <h3>Love City</h3>
                <p>Win: 300 | Risk: 100</p>
            </div>
            <div class="card" onclick="initGame('Abyss')">
                <div style="font-size:40px;">üíÄ</div>
                <h3>Get Beat</h3>
                <p>Win: 600 | Risk: 250</p>
            </div>
        </div>

        <button class="btn-secondary" onclick="toggleShop(true)">SKIN SHOP</button>
    </div>

    <!-- SHOP -->
    <div id="shop-menu" class="screen">
        <div style="position:absolute; top:30px; right:30px;">
            <button class="btn-primary" style="padding:10px 20px; font-size:24px;"
                onclick="toggleShop(false)">‚úï</button>
        </div>
        <div class="title" style="font-size:60px; margin-top: 40px;">ARMORY</div>
        <div class="card-grid" id="skinGrid"
            style="flex-wrap:wrap; justify-content:center; max-width:900px; max-height: 60vh; overflow-y: auto; padding: 10px;">
        </div>
        <button class="btn-primary" onclick="toggleShop(false)">BACK TO MENu</button>
    </div>

    <!-- VICTORY -->
    <div id="victory-screen" class="screen">
        <div class="title" style="color:#2ecc71; -webkit-text-fill-color:#2ecc71;">VICTORY!</div>
        <div class="currency-badge" style="margin:20px;">+<span id="winRewardText">0</span> üëë</div>
        <button class="btn-primary" onclick="showMenu()">CONTINUE</button>
    </div>

    <!-- DEFEAT -->
    <div id="respawn-screen" class="screen">
        <div class="title" style="color:#ff4757; -webkit-text-fill-color:#ff4757;">WASTED</div>
        <div class="currency-badge" style="margin:20px; background:#ff4757; color:#fff;">-<span id="lossText">0</span>
            üëë</div>
        <button class="btn-primary" onclick="showMenu()">RETRY</button>
    </div>

    <!-- SECRET CHEAT MENU -->
    <div id="cheat-menu" class="screen" style="z-index:9999;">
        <div class="card"
            style="width:400px; height:auto; border-color:#FFD700; box-shadow:0 0 50px #FFD700; background:#111;">
            <h3 style="color:#FFD700; font-size:40px;">DEV CONSOLE</h3>
            <p style="color:#fff; margin-bottom:20px;">ACCESS GRANTED: 2939</p>

            <button class="btn-primary" onclick="applyCheats(true)"
                style="width:100%; margin-bottom:10px; background:#FFD700; color:#000;">
                ‚ö° ACTIVATE GOD MODE
            </button>
            <p style="font-size:10px; color:#888;">(Unlimited Crowns, All Skins)</p>

            <button class="btn-secondary" onclick="applyCheats(false)"
                style="width:100%; margin-top:20px; color:#ff4757; border-color:#ff4757;">
                ‚ôªÔ∏è FACTORY RESET
            </button>
            <p style="font-size:10px; color:#888;">(0 Crowns, Reset Skins)</p>

            <button class="btn-secondary" onclick="document.getElementById('cheat-menu').classList.remove('active')"
                style="margin-top:30px;">
                CLOSE
            </button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- AUDIO SYSTEM ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            // Simple helper to generate retro sound effects safely
            try {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                const now = audioCtx.currentTime;

                if (type === 'shoot') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(250 + Math.random() * 50, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                }
                else if (type === 'dash') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(500, now);
                    osc.frequency.linearRampToValueAtTime(100, now + 0.2);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                }
                else if (type === 'hit') {
                    osc.type = 'sawtooth'; // Rough sound
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.linearRampToValueAtTime(50, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                }
                else if (type === 'kill') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(900, now + 0.15); // Coin-like chirp
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now); osc.stop(now + 0.15);
                }
                else if (type === 'powerup') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                    osc.frequency.linearRampToValueAtTime(1000, now + 0.3);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                    osc.start(now); osc.stop(now + 0.4);
                }
            } catch (e) { }
        }

        // --- MUSIC SYSTEM (Procedural Techno) ---
        let musicStarted = false;
        let musicTimer = null;

        function startMusic() {
            if (musicStarted) return;
            try {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                musicStarted = true;

                let beat = 0;
                setInterval(() => {
                    const t = audioCtx.currentTime;
                    // KICK
                    if (beat % 4 === 0) {
                        const osc = audioCtx.createOscillator();
                        const g = audioCtx.createGain();
                        osc.connect(g); g.connect(audioCtx.destination);
                        osc.frequency.setValueAtTime(150, t);
                        osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
                        g.gain.setValueAtTime(0.5, t);
                        g.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                        osc.start(t); osc.stop(t + 0.5);
                    }

                    // HI-HAT
                    if (beat % 2 !== 0) {
                        const osc = audioCtx.createOscillator();
                        const g = audioCtx.createGain();
                        osc.type = 'square'; // white noise approx
                        osc.connect(g); g.connect(audioCtx.destination);
                        // Filter
                        const f = audioCtx.createBiquadFilter();
                        f.type = 'highpass'; f.frequency.value = 10000;
                        osc.connect(f); f.connect(g);

                        g.gain.setValueAtTime(0.05, t);
                        g.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                        osc.start(t); osc.stop(t + 0.05);
                    }

                    // BASS
                    const note = [110, 110, 0, 110, 130, 0, 98, 0][beat % 8];
                    if (note) {
                        const osc = audioCtx.createOscillator();
                        const g = audioCtx.createGain();
                        osc.type = 'sawtooth';
                        osc.connect(g); g.connect(audioCtx.destination);
                        osc.frequency.setValueAtTime(note, t);
                        g.gain.setValueAtTime(0.1, t);
                        g.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                        osc.start(t); osc.stop(t + 0.2);
                    }

                    beat++;
                }, 125); // 120 BPM 8th notes roughly
            } catch (e) { }
        }

        window.addEventListener('click', startMusic, { once: true });
        window.addEventListener('keydown', startMusic, { once: true });

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Config
        const SKINS = {
            'Standard': { color: "#3498db", price: 0, speed: 6, fireRate: 180, hp: 100 },
            'Flash': { color: "#f1c40f", price: 200, speed: 10, fireRate: 140, hp: 80 },
            'Tank': { color: "#2ecc71", price: 600, speed: 4, fireRate: 300, hp: 200 },
            'Sniper': { color: "#e74c3c", price: 1200, speed: 7, fireRate: 600, hp: 60 },
            'Ghost': { color: "#d1ccc0", price: 3000, speed: 9, fireRate: 150, hp: 70 },
            'Inferno': { color: "#c0392b", price: 8000, speed: 7, fireRate: 110, hp: 120 },
            'Fart': { color: "#2c3e50", price: 5, speed: 8, fireRate: 130, hp: 90, ability: 'stealth' },
            'Neon': { color: "#fd79a8", price: 5000, speed: 8, fireRate: 90, hp: 150 }

        };

        const MODES = {
            'SURVIVAL': { title: 'SURVIVAL', desc: 'Survive the waves!', icon: 'üíÄ' },
            'DEFENSE': { title: 'DEFENSE', desc: 'Protect the Core!', icon: 'üõ°Ô∏è' },
            'BOSS': { title: 'BOSS RUSH', desc: 'Kill the Titan!', icon: 'üëπ' }
        };

        const ARENAS = [
            { name: "NEON CITY", color: "#1a1a2e", grid: "rgba(255, 255, 255, 0.05)", diff: 1, reward: 100, penalty: 10 },
            { name: "CRIMSON WASTES", color: "#2d0a0a", grid: "rgba(231, 76, 60, 0.2)", diff: 1.5, reward: 250, penalty: 50 },
            { name: "MIDNIGHT VOID", color: "#050510", grid: "rgba(142, 68, 173, 0.2)", diff: 2, reward: 500, penalty: 150 },
            { name: "FArt LABS", color: "#0a1f0a", grid: "rgba(46, 204, 113, 0.2)", diff: 1.2, reward: 150, penalty: 30 }
        ];
        let currentArena = ARENAS[0];

        // Error Handler
        window.onerror = function (msg, url, line) {
            const div = document.createElement('div');
            div.style.cssText = 'position:fixed;top:10px;left:10px;background:red;color:white;z-index:9999;padding:10px;font-size:12px;max-width:300px;word-wrap:break-word;';
            div.innerText = 'JS Error: ' + msg + ' (Line ' + line + ')';
            document.body.appendChild(div);
        };

        let state = {
            crowns: parseInt(localStorage.getItem('crowns_2026')) || 0,
            ownedSkins: JSON.parse(localStorage.getItem('ownedSkins_2026')) || ['Standard'],
            activeSkinID: localStorage.getItem('activeSkinID_2026') || 'Standard',
            gameActive: false,
            gameMode: 'SURVIVAL',
            screenShake: 0,
            mouseX: 0, mouseY: 0, mouseDown: false
        };

        let player, enemies = [], projectiles = [], particles = [], floaters = [], crystal;
        let botsRemaining;

        // Keys
        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', e => { state.mouseX = e.clientX; state.mouseY = e.clientY; });
        window.addEventListener('mousedown', () => state.mouseDown = true);
        window.addEventListener('mouseup', () => state.mouseDown = false);

        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize);
        resize();

        // SECRET CHEAT: Type 2939
        let cheatBuffer = "";
        window.addEventListener('keydown', e => {
            cheatBuffer += e.key;
            if (cheatBuffer.length > 4) cheatBuffer = cheatBuffer.slice(-4);
            if (cheatBuffer === "2939") {
                document.getElementById('cheat-menu').classList.add('active');
            }
        });

        window.applyCheats = (enable) => {
            if (enable) {
                // Save Backup if not already in God Mode
                if (!state.isGodMode) {
                    state.backup = {
                        crowns: state.crowns,
                        skins: [...state.ownedSkins],
                        active: state.activeSkinID
                    };
                    state.isGodMode = true;
                }

                state.crowns = 9999999;
                state.ownedSkins = Object.keys(SKINS);
                alert("GOD MODE ENABLED! (State Saved)");
            } else {
                // Restore Backup
                if (state.backup) {
                    state.crowns = state.backup.crowns;
                    state.ownedSkins = state.backup.skins;
                    state.activeSkinID = state.backup.active;
                    state.isGodMode = false;
                    alert("Restored your original progress.");
                } else {
                    state.crowns = 0;
                    state.ownedSkins = ['Standard'];
                    state.activeSkinID = 'Standard';
                    alert("Reset to defaults (No backup found).");
                }
            }
            save(); updateUI();
            if (document.getElementById('shop-menu').classList.contains('active')) renderShop();
            document.getElementById('cheat-menu').classList.remove('active');
        };

        window.triggerAbility = () => {
            if (!player || !player.ability || player.abilityUsed) return;

            if (player.ability === 'stealth') {
                player.isInvisible = true;
                player.abilityUsed = true;
                state.screenShake = 5;
                spawnParticles(player.x, player.y, "#333");

                const btn = document.getElementById('abilityBtn');
                if (btn) btn.style.opacity = 0.3; // Visually disabled

                // UI Text
                floaters.push({ x: player.x, y: player.y - 40, text: "STEALTH!", life: 60, color: "#fff" });

                setTimeout(() => {
                    player.isInvisible = false;
                    if (player.hp > 0) floaters.push({ x: player.x, y: player.y - 40, text: "EXPOSED", life: 60, color: "#f00" });
                }, 10000);
            }
        };

        // Helper to mimic roundRect (safe polyfill-ish or just rect)
        CanvasRenderingContext2D.prototype.safeRoundRect = function (x, y, w, h, r) {
            if (this.roundRect) { this.roundRect(x, y, w, h, r); }
            else { this.rect(x, y, w, h); }
        };

        // --- RENDERER (Professional 3D Vector Graphics) ---
        function drawCharacter(ctx, x, y, r, color, type, angle, isPlayer) {
            ctx.save();
            // Stealth/Invisibility Effect
            if (isPlayer && typeof player !== 'undefined' && player && player.isInvisible) ctx.globalAlpha = 0.3;

            ctx.translate(x, y);
            // Height bounce simulation
            const z = Math.abs(Math.sin(Date.now() * 0.005)) * 3;
            ctx.translate(0, -z);

            // Direction Flip
            const facingMouse = isPlayer ? (state.mouseX < x ? -1 : 1) : (player.x < x ? -1 : 1);
            if (facingMouse === -1) ctx.scale(-1, 1);

            // Soft Shadow
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.beginPath(); ctx.ellipse(0, r + 4 + z, r * 0.8, r * 0.2, 0, 0, Math.PI * 2); ctx.fill();

            // --- 3D BODY GRADIENT ---
            // Light source coming from top-left
            const grad = ctx.createRadialGradient(-r * 0.3, -r * 0.3, r * 0.1, 0, 0, r);
            grad.addColorStop(0, shadeColor(color, 40)); // Specular Highlight
            grad.addColorStop(0.3, color);
            grad.addColorStop(1, shadeColor(color, -30)); // Deep Shadow

            ctx.fillStyle = grad;
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.lineWidth = 2;

            // Special Effects per Type
            if (type === 'Neon') {
                ctx.shadowBlur = 15; ctx.shadowColor = color;
                ctx.strokeStyle = "#fff";
            }
            if (type === 'Inferno') {
                ctx.shadowBlur = 20; ctx.shadowColor = "#f39c12";
            }
            if (type === 'Ghost') {
                ctx.globalAlpha = 0.6;
            }

            ctx.beginPath();
            // Unique shapes per type
            if (type === 'Tank' || type === 1) { // Heavy Boxy
                ctx.safeRoundRect(-r, -r * 0.9, r * 2, r * 1.8, 8);
            } else if (type === 'Sniper') { // Stealthy Triangle
                ctx.moveTo(0, -r * 1.1); ctx.lineTo(r * 0.9, r * 0.8); ctx.lineTo(-r * 0.9, r * 0.8); ctx.closePath();
            } else if (type === 'Flash' || type === 'Inferno') {
                ctx.ellipse(0, 0, r * 1.1, r, -0.2, 0, Math.PI * 2);
            } else { // Standard Round
                ctx.arc(0, 0, r, 0, Math.PI * 2);
            }
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.stroke();

            // --- DETAILS (Visor / Eyes) ---
            if (isPlayer) {
                // Pro Visor (Glassy Reflection)
                const vGrad = ctx.createLinearGradient(0, -r, 0, r);
                if (type === 'Neon') {
                    vGrad.addColorStop(0, "#fff"); vGrad.addColorStop(1, "#0ff");
                } else if (type === 'Sniper') {
                    vGrad.addColorStop(0, "#333"); vGrad.addColorStop(1, "#000");
                } else {
                    vGrad.addColorStop(0, "#444"); vGrad.addColorStop(1, "#111");
                }

                ctx.fillStyle = vGrad;
                ctx.beginPath();

                if (type === 'Tank') {
                    ctx.rect(-r * 0.7, -r * 0.4, r * 1.4, r * 0.3); // Slit visor
                } else if (type === 'Sniper') {
                    ctx.ellipse(0, -r * 0.2, r * 0.6, r * 0.4, 0, 0, Math.PI * 2); // Goggles
                } else {
                    ctx.safeRoundRect(-r * 0.7, -r * 0.35, r * 1.4, r * 0.6, 10); // Wide visor
                }
                ctx.fill();
                ctx.stroke();

                // Visor Glare
                ctx.fillStyle = "rgba(255,255,255,0.7)";
                ctx.beginPath();
                if (type === 'Tank') ctx.rect(-r * 0.6, -r * 0.35, r * 1.2, 2);
                else ctx.ellipse(-r * 0.4, -r * 0.25, r * 0.25, r * 0.1, -0.5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Enemy Faces (Menacing)
                ctx.fillStyle = "#fff";
                ctx.beginPath();
                if (type === 4) { // Boss
                    ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2);
                } else {
                    ctx.arc(r * 0.4, -r * 0.1, r * 0.25, 0, Math.PI * 2);
                    ctx.arc(0, -r * 0.1, r * 0.25, 0, Math.PI * 2);
                }
                ctx.fill();

                ctx.fillStyle = "#000"; // Pupil
                ctx.beginPath();
                if (type === 4) ctx.arc(0, 0, r * 0.2, 0, Math.PI * 2);
                else {
                    ctx.arc(r * 0.45, -r * 0.1, r * 0.1, 0, Math.PI * 2);
                    ctx.arc(0.05, -r * 0.1, r * 0.1, 0, Math.PI * 2);
                }
                ctx.fill();
            }

            // Hands (Floating Spheres)
            const hGrad = ctx.createRadialGradient(-r * 0.1, -r * 0.1, 2, 0, 0, r * 0.3);
            hGrad.addColorStop(0, shadeColor(color, 20));
            hGrad.addColorStop(1, shadeColor(color, -40));
            ctx.fillStyle = hGrad;

            // Back Hand
            ctx.beginPath(); ctx.arc(-r * 0.6, r * 0.5, r * 0.25, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

            // Gun / Front Hand
            if (isPlayer) {
                ctx.save();
                ctx.translate(r * 0.6, r * 0.4);
                ctx.rotate(angle * facingMouse);

                // Fancy Gun
                ctx.fillStyle = "#222";
                ctx.beginPath(); ctx.safeRoundRect(-5, -5, 30, 10, 2); ctx.fill();
                ctx.fillStyle = "#444"; ctx.fillRect(0, 0, 8, 15);
                ctx.fillStyle = "#000"; ctx.fillRect(20, -6, 5, 2); // Sight
                ctx.restore();
            } else {
                ctx.beginPath(); ctx.arc(r * 0.6, r * 0.5, r * 0.25, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            }

            ctx.restore();
        }

        // Classes
        class Entity {
            constructor(x, y, radius, color) {
                this.x = x; this.y = y; this.radius = radius; this.color = color;
                this.isPlayer = false;
                this.skinID = 'Standard';
            }
            drawShadow(ctx) {
                // Handled in drawCharacter now to keep z-order easy, can remove or keep empty
            }
            drawBody(ctx) {
                // Pass correct type ID
                const type = this.isPlayer ? this.skinID : (this.type || 0);
                drawCharacter(ctx, this.x, this.y, this.radius, this.color, type, 0, this.isPlayer);
            }
        }

        class Crystal extends Entity {
            constructor() {
                super(canvas.width / 2, canvas.height / 2, 40, '#00d2d3');
                this.hp = 200; this.maxHp = 200;
            }
            drawBody(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                const scale = 1 + Math.sin(Date.now() * 0.005) * 0.05;
                ctx.scale(scale, scale);

                // Glow
                ctx.shadowBlur = 20; ctx.shadowColor = this.color;

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(0, -40); ctx.lineTo(30, -10); ctx.lineTo(0, 40); ctx.lineTo(-30, -10);
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.strokeStyle = "rgba(255,255,255,0.8)"; ctx.lineWidth = 3; ctx.stroke();

                // HP Bar
                ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(-30, 50, 60, 6);
                ctx.fillStyle = "#0f0"; ctx.fillRect(-30, 50, 60 * (this.hp / this.maxHp), 6);

                ctx.restore();
            }
        }

        class Bot extends Entity {
            constructor(type) {
                // Spawn logic
                const side = Math.floor(Math.random() * 4);
                let x, y;
                if (side === 0) { x = Math.random() * canvas.width; y = -50; }
                if (side === 1) { x = canvas.width + 50; y = Math.random() * canvas.height; }
                if (side === 2) { x = Math.random() * canvas.width; y = canvas.height + 50; }
                if (side === 3) { x = -50; y = Math.random() * canvas.height; }

                super(x, y, 20, "#ff4757");
                this.maxHp = 3;
                this.speed = 5; // Default speed

                // Aggressive Stats
                if (type === 1) { // Tank
                    this.radius = 30; this.maxHp = 10; this.color = "#574b90"; this.speed = 3;
                } else if (type === 2) { // Fast
                    this.radius = 15; this.maxHp = 2; this.color = "#ffa502"; this.speed = 7;
                } else if (type === 3) { // Shooter
                    this.radius = 20; this.maxHp = 3; this.color = "#ff4757"; this.speed = 4;
                } else if (type === 4) { // BOSS
                    this.radius = 80; this.maxHp = 300; this.color = "#2c3e50"; this.speed = 3;
                    this.x = x; this.y = y;
                }
                this.hp = this.maxHp;
                this.type = type;
                this.lastShoot = 0;
            }
            update() {
                let target = player;
                if (state.gameMode === 'DEFENSE' && crystal) target = crystal;

                // Stealth Check
                if (player && player.isInvisible && target === player) target = null;

                if (target) {
                    const angle = Math.atan2(target.y - this.y, target.x - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                } else {
                    // Confused movement
                    this.x += (Math.random() - 0.5) * 4;
                    this.y += (Math.random() - 0.5) * 4;
                }
            }
        }

        // Helper: Darken/Lighten HEX color
        function shadeColor(color, percent) {
            let R = parseInt(color.substring(1, 3), 16);
            let G = parseInt(color.substring(3, 5), 16);
            let B = parseInt(color.substring(5, 7), 16);
            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);
            R = (R < 255) ? R : 255; G = (G < 255) ? G : 255; B = (B < 255) ? B : 255;
            return "#" + ((1 << 24) + (R << 16) + (G << 8) + B).toString(16).slice(1);
        }

        function setMode(mode) {
            state.gameMode = mode;
            // Visually update buttons (added dynamically in next step)
            document.querySelectorAll('.mode-btn').forEach(b => {
                b.style.borderColor = b.innerText.includes(mode) ? '#FFD700' : 'transparent';
                b.style.transform = b.innerText.includes(mode) ? 'scale(1.1)' : 'scale(1)';
            });
        }

        function spawnParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x, y, color,
                    vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                    life: 1.0
                });
            }
        }

        function initGame(id) {
            // Select Arena
            if (typeof id === 'number' && ARENAS[id]) {
                currentArena = ARENAS[id];
            } else {
                currentArena = ARENAS[Math.floor(Math.random() * ARENAS.length)];
            }

            // Boss Rush Mode Override
            if (state.gameMode === 'BOSS') {
                botsRemaining = 1; // Just one boss
            } else if (state.gameMode === 'DEFENSE') {
                botsRemaining = 999; // Endless
            } else {
                botsRemaining = currentArena.bots || 20;
            }

            const pConf = SKINS[state.activeSkinID] || SKINS['Standard'];
            player = new Entity(canvas.width / 2, canvas.height / 2, 25, pConf.color);
            player.isPlayer = true;
            player.skinID = state.activeSkinID;
            player.hp = pConf.hp; player.maxHp = pConf.hp;
            player.conf = pConf; player.lastShoot = 0; player.angle = 0;
            // Ability Init
            player.ability = pConf.ability || null;
            player.abilityUsed = false;
            player.isInvisible = false;

            // Show Ability Button if applicable
            const aBtn = document.getElementById('abilityBtn');
            if (aBtn) {
                if (player.ability) { aBtn.style.display = 'flex'; aBtn.style.opacity = 1; }
                else aBtn.style.display = 'none';
            }

            // Crystal Setup
            crystal = null;
            if (state.gameMode === 'DEFENSE') {
                crystal = new Crystal();
            }

            enemies = []; projectiles = []; particles = []; floaters = []; powerups = [];

            if (state.gameMode === 'BOSS') {
                enemies.push(new Bot(4)); // Spawn Boss immediately
            } else if (state.gameMode === 'SURVIVAL') {
                enemies.push(new Bot(0)); // Force 1 spawn so user sees action immediately
                if (botsRemaining > 0) botsRemaining--;
            }

            state.gameActive = true;
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        // Create explicit mode updaters
        function spawnBot() {
            console.log("Spawning Bot...");
            // Safety fallback
            const diff = currentArena ? currentArena.diff : 1.0;

            const r = Math.random();
            let type = 0;
            if (diff > 2 && r > 0.85) type = 2; // Fast
            else if (diff > 1.5 && r > 0.70) type = 1; // Tank
            else if (diff > 1.0 && r > 0.55) type = 3; // Shooter
            enemies.push(new Bot(type));
        }

        function updateSurvival() {
            // Strict Rule: If we have bots left to spawn, SPAWN THEM.
            // Don't leave the player hanging with 0 enemies.
            if (botsRemaining > 0) {
                // formatting: keep strict
                const shouldSpawn = enemies.length < 2 || Math.random() < 0.05;
                if (shouldSpawn) {
                    spawnBot();
                    botsRemaining--;
                }
            } else if (enemies.length === 0) {
                // All bots spawned and killed
                endGame(true);
            }
        }

        function updateDefense() {
            // Constant pressure
            if (Math.random() < 0.03) {
                spawnBot();
            }
            // Defense win condition? Maybe time based later. For now endless fun.
        }

        function updateBoss() {
            // Win if boss (last enemy) dies
            if (enemies.length === 0) endGame(true);
        }

        function gameLoop() {
            if (!state.gameActive) return;

            try {
                // Debug Heartbeat
                const dHud = document.getElementById('debugHUD');
                if (dHud) dHud.innerText = `[${Date.now() % 100}] En: ${enemies.length} | Rem: ${botsRemaining} | Mode: ${state.gameMode}`;

                // Screenshake
                let dx = 0, dy = 0;
                if (state.screenShake > 0) {
                    dx = (Math.random() - 0.5) * state.screenShake;
                    dy = (Math.random() - 0.5) * state.screenShake;
                    state.screenShake *= 0.9;
                }

                // Draw Floor
                ctx.fillStyle = currentArena ? currentArena.color : '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Cool Grid Pattern
                ctx.strokeStyle = currentArena ? currentArena.grid : "rgba(255,255,255,0.05)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                // Perspective grid lines? No, staying top down but cleaner
                for (let i = 0; i < canvas.width; i += 80) { ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); }
                for (let i = 0; i < canvas.height; i += 80) { ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); }
                ctx.stroke();

                // Arena Name HUD
                ctx.fillStyle = "rgba(255,255,255,0.1)";
                ctx.font = "900 100px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(currentArena ? currentArena.name : "", canvas.width / 2, canvas.height / 2);

                // Camera Lean logic
                const camX = (state.mouseX - canvas.width / 2) * 0.1;
                const camY = (state.mouseY - canvas.height / 2) * 0.1;

                ctx.save();
                ctx.translate(dx - camX, dy - camY);

                // --- UPDATE STEP ---
                if (state.gameMode === 'SURVIVAL') updateSurvival();
                else if (state.gameMode === 'DEFENSE') updateDefense();
                else if (state.gameMode === 'BOSS') updateBoss();

                // Dash Ability (Spacebar)
                if (typeof player.dashCooldown === 'undefined') player.dashCooldown = 0;
                if (player.dashCooldown > 0) player.dashCooldown--;
                if (keys['Space'] && player.dashCooldown <= 0) {
                    player.dashCooldown = 100; // Cooldown
                    const dashAngle = Math.atan2(state.mouseY - player.y, state.mouseX - player.x);
                    player.x += Math.cos(dashAngle) * 150;
                    player.y += Math.sin(dashAngle) * 150;
                    playSound('dash');
                    state.screenShake = 10;
                    spawnParticles(player.x, player.y, "#fff");
                }

                // Powerups System
                if (state.gameActive && Math.random() < 0.002 && powerups.length < 3) {
                    powerups.push({ x: 50 + Math.random() * (canvas.width - 100), y: 50 + Math.random() * (canvas.height - 100), type: 'HP', life: 1000 });
                }

                powerups.forEach(p => {
                    p.life--;
                    // Render Powerup
                    const bob = Math.sin(Date.now() * 0.005) * 5;
                    ctx.shadowBlur = 15; ctx.shadowColor = "#2ecc71";
                    ctx.fillStyle = "#2ecc71";
                    ctx.beginPath(); ctx.safeRoundRect(p.x - 15, p.y - 15 + bob, 30, 30, 8); ctx.fill();
                    ctx.fillStyle = "#fff"; ctx.font = "bold 20px Arial"; ctx.fillText("‚úö", p.x - 8, p.y + 8 + bob);
                    ctx.shadowBlur = 0;

                    // Collision
                    if (Math.hypot(p.x - player.x, p.y - player.y) < 40) {
                        p.dead = true;
                        player.hp = Math.min(player.maxHp, player.hp + 50);
                        playSound('powerup');
                        floaters.push({ x: player.x, y: player.y, text: "+50 HP", color: "#2ecc71", life: 50, scale: 1.5 });
                        spawnParticles(p.x, p.y, "#2ecc71");
                    }
                });
                powerups = powerups.filter(p => !p.dead && p.life > 0);

                // Ability: Stealth (Press E)
                if (keys['KeyE']) triggerAbility();

                // Player Move
                const spd = player.conf.speed;
                if (keys['KeyW']) player.y -= spd;
                if (keys['KeyS']) player.y += spd;
                if (keys['KeyA']) player.x -= spd;
                if (keys['KeyD']) player.x += spd;
                player.x = Math.max(25, Math.min(canvas.width - 25, player.x));
                player.y = Math.max(25, Math.min(canvas.height - 25, player.y));
                player.angle = Math.atan2(state.mouseY - player.y, state.mouseX - player.x);

                // Player Shoot
                if (state.mouseDown && Date.now() - player.lastShoot > player.conf.fireRate) {
                    playSound('shoot');
                    // Muzzle Flash
                    particles.push({
                        x: player.x + Math.cos(player.angle) * 30,
                        y: player.y + Math.sin(player.angle) * 30,
                        vx: 0, vy: 0, life: 0.5, color: '#fff', size: 10, isMuzzle: true
                    });

                    projectiles.push({
                        x: player.x, y: player.y,
                        vx: Math.cos(player.angle) * 20, vy: Math.sin(player.angle) * 20,
                        color: player.conf.color,
                        isEnemy: false
                    });
                    player.lastShoot = Date.now();
                    state.screenShake = 5;

                    // Recoil
                    player.x -= Math.cos(player.angle) * 4;
                    player.y -= Math.sin(player.angle) * 4;
                }

                // Projectiles
                projectiles.forEach(p => {
                    p.x += p.vx; p.y += p.vy;
                    if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) p.dead = true;

                    // Draw Proj
                    ctx.shadowBlur = 10; ctx.shadowColor = p.color;
                    ctx.fillStyle = "#fff";
                    ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.shadowBlur = 0;
                });
                projectiles = projectiles.filter(p => !p.dead);

                // Enemies
                enemies.forEach(en => {
                    en.update();

                    if (en.type === 3) {
                        const dist = Math.hypot(player.x - en.x, player.y - en.y);
                        if (dist < 300) {
                            const a = Math.atan2(player.y - en.y, player.x - en.x);
                            en.x -= Math.cos(a) * 1; en.y -= Math.sin(a) * 1;
                        }
                        if (Date.now() - (en.lastShoot || 0) > 2000) {
                            const a = Math.atan2(player.y - en.y, player.x - en.x);
                            projectiles.push({
                                x: en.x, y: en.y,
                                vx: Math.cos(a) * 8, vy: Math.sin(a) * 8,
                                color: '#ff0000',
                                isEnemy: true
                            });
                            en.lastShoot = Date.now();
                        }
                    }

                    if (Math.hypot(player.x - en.x, player.y - en.y) < player.radius + en.radius) {
                        player.hp--;
                        playSound('hit'); // AUDIO
                        state.screenShake = 15;
                        const a = Math.atan2(player.y - en.y, player.x - en.x);
                        player.x += Math.cos(a) * 30;
                        player.y += Math.sin(a) * 30;
                        const df = document.getElementById('dmgFlash');
                        if (df) { df.style.opacity = 0.5; setTimeout(() => df.style.opacity = 0, 100); }
                        if (player.hp <= 0) endGame(false);
                    }

                    projectiles.forEach(p => {
                        if (p.dead) return;
                        if (p.isEnemy) {
                            if (Math.hypot(p.x - player.x, p.y - player.y) < player.radius + 5) {
                                player.hp -= 5;
                                playSound('hit'); // AUDIO
                                p.dead = true;
                                state.screenShake = 10;
                                const df = document.getElementById('dmgFlash');
                                if (df) { df.style.opacity = 0.5; setTimeout(() => df.style.opacity = 0, 100); }
                                if (player.hp <= 0) endGame(false);
                            }
                        } else if (Math.hypot(p.x - en.x, p.y - en.y) < en.radius + 10) {
                            p.dead = true;
                            en.hp--;
                            spawnParticles(en.x, en.y, "#fff");
                            floaters.push({ x: en.x, y: en.y, text: "10", life: 30, color: "#fff" });

                            if (en.hp <= 0) {
                                en.dead = true;
                                playSound('kill'); // AUDIO
                                spawnParticles(en.x, en.y, en.color);
                                state.screenShake = 10;
                                floaters.push({ x: en.x, y: en.y, text: "KO!", life: 50, color: "#ffd700", scale: 2 });
                            } else {
                                en.x += p.vx * 0.5;
                                en.y += p.vy * 0.5;
                            }
                        }
                    });
                });
                enemies = enemies.filter(e => !e.dead);

                // DRAW STEP
                player.drawShadow(ctx);
                enemies.forEach(e => e.drawShadow(ctx));
                enemies.forEach(e => e.drawBody(ctx));
                player.drawBody(ctx);

                // Gun
                ctx.save();
                ctx.translate(player.x, player.y);
                if (state.mouseX < player.x) ctx.scale(1, -1);
                ctx.rotate(player.angle);
                ctx.fillStyle = "#333"; ctx.fillRect(10, -8, 24, 16);
                ctx.fillStyle = "#000"; ctx.fillRect(10, -8, 24, 16);
                ctx.fillStyle = "#555"; ctx.fillRect(12, -6, 20, 12);
                ctx.restore();

                // Particles
                particles.forEach(p => {
                    if (p.isMuzzle) {
                        p.life -= 0.1;
                        if (p.life > 0) {
                            ctx.fillStyle = p.color;
                            ctx.globalAlpha = Math.max(0, p.life);
                            ctx.beginPath(); ctx.arc(p.x, p.y, Math.max(0, p.size * p.life), 0, Math.PI * 2); ctx.fill();
                            ctx.globalAlpha = 1.0;
                        }
                    } else {
                        p.x += p.vx; p.y += p.vy; p.life -= 0.05;
                        ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.life);
                        ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                    if (p.life <= 0) p.dead = true;
                });
                particles = particles.filter(p => !p.dead);

                // Floaters
                ctx.font = "900 20px 'Black Han Sans'";
                ctx.textAlign = "center";
                floaters.forEach(f => {
                    f.y -= 1; f.life--;
                    ctx.fillStyle = "black"; ctx.fillText(f.text, f.x + 2, f.y + 2);
                    ctx.fillStyle = f.color; ctx.fillText(f.text, f.x, f.y);
                    if (f.life <= 0) f.dead = true;
                });
                floaters = floaters.filter(f => !f.dead);

                ctx.restore();

            } catch (e) {
                console.error("Game Loop Crash:", e);
                const dHud = document.getElementById('debugHUD');
                if (dHud) dHud.innerText = "CRASH: " + e.message;
                state.gameActive = false;
            }



            // Lighting Overlay (Vignette)
            const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, canvas.height / 3, canvas.width / 2, canvas.height / 2, canvas.height);
            gradient.addColorStop(0, "rgba(0,0,0,0)");
            gradient.addColorStop(1, "rgba(0,0,0,0.6)");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // UI Updates
            const pct = (player.hp / player.maxHp) * 100;
            document.getElementById('hpBar').style.width = pct + "%";

            requestAnimationFrame(gameLoop);
        }

        function endGame(win) {
            state.gameActive = false;
            if (win) {
                document.getElementById('winRewardText').innerText = currentArena.reward;
                document.getElementById('victory-screen').classList.add('active');
                state.crowns += currentArena.reward;
            } else {
                document.getElementById('lossText').innerText = currentArena.penalty;
                document.getElementById('respawn-screen').classList.add('active');
                state.crowns = Math.max(0, state.crowns - currentArena.penalty);
            }
            updateUI(); save();
        }

        // UI Logic
        function updateUI() {
            document.getElementById('crownText').innerText = state.crowns;
            if (document.getElementById('menuCrowns')) document.getElementById('menuCrowns').innerText = state.crowns;
        }

        function save() {
            localStorage.setItem('crowns_2026', state.crowns);
            localStorage.setItem('ownedSkins_2026', JSON.stringify(state.ownedSkins));
            localStorage.setItem('activeSkinID_2026', state.activeSkinID);
        }

        function toggleShop(o) {
            document.getElementById('menu').classList.toggle('active', !o);
            document.getElementById('shop-menu').classList.toggle('active', o);
            if (o) renderShop();
        }

        function showMenu() {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('menu').classList.add('active');
            renderArenas();
        }

        function renderArenas() {
            const list = document.getElementById('arena-list');
            if (!list) return;
            list.innerHTML = "";
            ARENAS.forEach((a, i) => {
                const el = document.createElement('div');
                el.className = "card";
                el.style.width = "160px"; // Simpler layout
                el.onclick = () => { playSound('shoot'); initGame(i); };
                el.innerHTML = `
                   <div style="width:100%; height:60px; background:${a.color}; border-radius:8px; margin-bottom:10px; border:2px solid ${a.grid}; box-shadow: inset 0 0 20px rgba(0,0,0,0.5);"></div>
                   <h3 style="font-size:14px; margin:0;">${a.name}</h3>
                   <p style="font-size:11px; color:#aaa; margin-top:5px;">Prize: ${a.reward}</p>
               `;
                list.appendChild(el);
            });
        }

        function generateSkinPreviews() {
            const tempCan = document.createElement('canvas');
            tempCan.width = 150; tempCan.height = 150;
            const tCtx = tempCan.getContext('2d');

            Object.keys(SKINS).forEach(k => {
                const s = SKINS[k];
                tCtx.clearRect(0, 0, 150, 150);

                // Mock state for nice presentation
                const oldX = state.mouseX;
                state.mouseX = 1000; // Force face right

                // Draw larger preview
                // ctx, x, y, r, color, type, angle, isPlayer
                drawCharacter(tCtx, 75, 80, 40, s.color, k, 0, true);

                state.mouseX = oldX;

                s.previewUrl = tempCan.toDataURL();
            });
        }

        function renderShop() {
            // Lazy load previews
            if (!SKINS['Standard'].previewUrl) generateSkinPreviews();

            const g = document.getElementById('skinGrid'); g.innerHTML = '';
            Object.keys(SKINS).forEach(k => {
                const s = SKINS[k]; const own = state.ownedSkins.includes(k);
                g.innerHTML += `
            <div class="card" onclick="buySkin('${k}')" style="${state.activeSkinID === k ? 'border-color:#FFD700; transform:scale(1.05);' : ''}; width:200px;">
                <div style="height:120px; display:flex; align-items:center; justify-content:center;">
                    <img src="${s.previewUrl}" style="width:120px; height:120px; object-fit:contain; filter:drop-shadow(0 10px 10px rgba(0,0,0,0.5));">
                </div>
                <h3 style="margin:0; font-size:28px;">${k}</h3>
                <div style="display:flex; justify-content:space-between; padding:0 20px; font-size:12px; color:#aaa; margin-bottom:10px;">
                    <span>‚ù§Ô∏è ${s.hp}</span>
                    <span>‚ö° ${s.speed}</span>
                </div>
                <div class="btn-secondary" style="margin-top:0; padding:10px; width:100%; border-radius:0 0 15px 15px; border:none; border-top:2px solid #000;">
                    ${own ? 'EQUIP' : 'üëë ' + s.price}
                </div>
            </div>`;
            });
        }

        window.buySkin = (id) => {
            const s = SKINS[id];
            if (state.ownedSkins.includes(id)) { state.activeSkinID = id; }
            else if (state.crowns >= s.price) {
                state.crowns -= s.price;
                state.ownedSkins.push(id);
                state.activeSkinID = id;
            }
            save(); updateUI(); renderShop();
        }

        updateUI();
        renderArenas();

    </script>
</body>

</html>
